---
title: "test4"
author: "Jayden Gould, Harrison Funk, Elijah DiFuria, Kian Jadbabaei"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# Master Function: Dynamically routes shape parameter 'a' to the correct mathematical algorithm
generate_gamma_complete <- function(n, a) {
  if (a <= 0) stop("Shape parameter 'a' must be strictly positive (> 0)")
  
  if (a <= 1) {
    # Handles infinite asymptote at zero
    return(generate_gamma_GS(n, a))
  } else if (a <= 2.53278) {
    # Handles parameters where GO polynomial bounds are invalid
    return(generate_gamma_GC(n, a))
  } else {
    # Highly optimized Normal-Exponential split for large parameters
    return(generate_gamma_GO(n, a))
  }
}
```

```{r}
# Algorithm GS: Piecewise Envelope
generate_gamma_GS <- function(n, a) {
  samples <- numeric(n)
  
  # Step 1: Set b <- (e+a)/e 
  b <- (exp(1) + a) / exp(1) 
  
  for (i in 1:n) {
    accepted <- FALSE
    while (!accepted) {
      # Step 1: Generate u. Set p <- b * u 
      u <- runif(1)
      p <- b * u
      
      # Step 1: If p >= 1 go to 3. (Meaning if p <= 1, proceed to Step 2) 
      if (p <= 1) {
        
        # Step 2: (Case x <= 1). Set x <- p^(1/a). Generate u'. 
        x <- p^(1 / a)
        u_prime <- runif(1)
        
        # Step 2: If u' > e^(-x) go back to 1. Otherwise deliver x. 
        # (Evaluated on logarithmic scale to prevent floating-point precision loss)
        if (log(u_prime) <= -x) {
          samples[i] <- x
          accepted <- TRUE
        }
      } else {
        
        # Step 3: (Case x > 1). Set x <- -ln((b-p)/a). Generate u'. 
        x <- -log((b - p) / a)
        u_prime <- runif(1)
        
        # Step 3: If u' > x^(a-1) go back to 1. Otherwise deliver x. 
        # (Evaluated on logarithmic scale to prevent floating-point precision loss)
        if (log(u_prime) <= (a - 1) * log(x)) {
          samples[i] <- x
          accepted <- TRUE
        }
      }
    }
  }
  return(samples)
}
```

```{r}
# Algorithm GC: Cauchy Envelope Method
generate_gamma_GC <- function(n, a) {
  samples <- numeric(n)
  
  # Step 1: Set b <- a-1, A <- 2a-1, and s <- sqrt(A) 
  b <- a - 1
  A <- 2 * a - 1
  s <- sqrt(A)
  
  for(i in 1:n) {
    accepted <- FALSE
    while(!accepted) {
      # Step 2: Generate u. Set t <- s * tan(pi * (u - 0.5)) and x <- b + t. 
      u <- runif(1)
      t <- s * tan(pi * (u - 0.5))
      x <- b + t
      
      # Step 3: If x < 0 go to 2. 
      if(x >= 0) {
        
        # Step 4: Generate u'. If u' > exp(b * ln(x/b) - t + ln(1 + t^2/A)) go to 2. 
        u2 <- runif(1)
        
        # Evaluated on a log scale to prevent exp() hardware overflow
        test_val <- b * log(x / b) - t + log(1 + (t^2 / A))
        
        if(log(u2) <= test_val) {
          # Step 4: Otherwise deliver x. 
          samples[i] <- x
          accepted <- TRUE
        }
      }
    }
  }
  return(samples)
}
```

```{r}
# Algorithm GO: Modified Normal-Exponential Method with Squeeze Bounds
generate_gamma_GO <- function(n, a) {
  samples <- numeric(n)
  
  # Step 1: Set mu <- a-1, sigma <- sqrt(a + sqrt(8/3)*sqrt(a)), W <- sigma^2/mu, 
  # d <- sqrt(6)*sigma, and b <- mu+d 
  mu <- a - 1
  sigma <- sqrt(a + sqrt(8/3) * sqrt(a))
  W <- sigma^2 / mu
  d <- sqrt(6) * sigma
  b_bound <- mu + d
  beta_const <- 0.009572265238289
  
  for(i in 1:n) {
    accepted <- FALSE
    while(!accepted) {
      
      # Step 2: Generate u. If u <= 0.009572265238289 go to 8. 
      u1 <- runif(1)
      
      if(u1 <= beta_const) {
        # --- TAIL REGION (Exponential Envelope) ---
        
        # Step 8: Take a sample s from the standard exponential distribution and set x <- b(1+s/d). 
        s_exp <- rexp(1)
        x <- b_bound * (1 + s_exp / d)
        
        # Step 9: Generate u. If ln u > mu(2+ln(x/mu)-x/b) + 3.7203284924588 - b - ln(d/b) go to 2. 
        u2 <- runif(1)
        
        # Exact logarithmic expansion applied dynamically to bypass textual rounding errors
        log_f <- mu * log(x / mu) - x + mu
        log_h <- mu * log(b_bound / mu) - (1 - mu / b_bound) * x
        log_r <- log(beta_const / (1 - beta_const)) + 0.5 * log(2 * pi * sigma^2) + 
                 mu * log(mu / b_bound) + log(d / b_bound) + d
                 
        if(log(u2) <= log_f - (log_r + log_h)) {
          # Step 9: Otherwise deliver x. 
          samples[i] <- x
          accepted <- TRUE
        }
      } else {
        # --- CORE REGION (Normal Envelope) ---
        
        # Step 3: Take a sample s from the standard normal distribution and set x <- mu + sigma*s. 
        s_norm <- rnorm(1)
        x <- mu + sigma * s_norm
        
        # Step 3: If x < 0 or x > b go to 2. 
        if(x >= 0 && x <= b_bound) {
          
          # Step 4: Generate u and set S <- s^2/2. 
          u2 <- runif(1)
          S <- (s_norm^2) / 2
          
          # Lemma 3: Quick Acceptance Squeeze Bounds logic 
          # Step 4: If s >= 0 go to 6. 
          if (s_norm >= 0) {
            
            # Step 6: If u <= 1 - S(W-1) deliver x. 
            L <- 1 - S * (W - 1)
          } else {
            
            # Step 5: If u <= 1 - S((1-2s/V)W-1) deliver x. 
            # (Substituted with the explicit Lemma 3 polynomial from the text)
            L <- 1 - S * (W - 1) + (s_norm^3 / sqrt(a)) * W
          }
          
          if(u2 <= L) {
            samples[i] <- x
            accepted <- TRUE
          } else {
            # Step 7 (Full Evaluation): If ln u > mu(1+ln(x/mu)) - x + S go to 2, otherwise deliver x. 
            if(log(u2) <= mu * (1 + log(x / mu)) - x + S) {
              samples[i] <- x
              accepted <- TRUE
            }
          }
        }
      }
    }
  }
  return(samples)
}
```

```{r}
# Beta Generation via Gamma Ratio (Ahrens & Dieter, 1974, Page 5)
generate_beta_from_gamma <- function(n, a, b) {
  
  # Step 1: Generate a sample x from a Gamma distribution gamma(a) 
  x <- generate_gamma_complete(n, a)
  
  # Step 2: Generate a sample y from a Gamma distribution gamma(b), independent of x 
  y <- generate_gamma_complete(n, b)
  
  # Step 3 & 4: Calculate the ratio x / (x + y). The resulting value follows a Beta(a,b) distribution 
  beta_samples <- x / (x + y)
  
  return(beta_samples)
}
```

```{r}
# Generate 10,000 samples for each segment of the architecture
set.seed(42)
n_samples <- 10000

# Route through the master wrapper function
samples_GS <- generate_gamma_complete(n_samples, a = 0.5)
samples_GC <- generate_gamma_complete(n_samples, a = 2.0)
samples_GO <- generate_gamma_complete(n_samples, a = 10.0)

# Generate Beta samples using the Gamma Ratio method
samples_Beta <- generate_beta_from_gamma(n_samples, a = 2.5, b = 5.0)

# Set up a 2x2 plotting grid to display the histograms
par(mfrow=c(2, 2))

# ---------------------------------------------------------
# Plot 1: Algorithm GS (a = 0.5)
# ---------------------------------------------------------
hist(samples_GS, probability = TRUE, breaks = 50, col = "lightblue",
     main = "GS Module: Gamma(a=0.5)", xlab = "x", ylab = "Density", border = "white")
curve(dgamma(x, shape = 0.5, rate = 1), add = TRUE, col = "darkred", lwd = 2)
legend("topright", legend = c("Empirical", "Theoretical"),
       fill = c("lightblue", NA), border = c("white", NA),
       col = c(NA, "darkred"), lwd = c(NA, 2), bty = "n")

# ---------------------------------------------------------
# Plot 2: Algorithm GC (a = 2.0)
# ---------------------------------------------------------
hist(samples_GC, probability = TRUE, breaks = 50, col = "lightgreen",
     main = "GC Module: Gamma(a=2.0)", xlab = "x", ylab = "Density", border = "white")
curve(dgamma(x, shape = 2.0, rate = 1), add = TRUE, col = "darkblue", lwd = 2)
legend("topright", legend = c("Empirical", "Theoretical"),
       fill = c("lightgreen", NA), border = c("white", NA),
       col = c(NA, "darkblue"), lwd = c(NA, 2), bty = "n")

# ---------------------------------------------------------
# Plot 3: Algorithm GO (a = 10.0)
# ---------------------------------------------------------
hist(samples_GO, probability = TRUE, breaks = 50, col = "lightcoral",
     main = "GO Module: Gamma(a=10.0)", xlab = "x", ylab = "Density", border = "white")
curve(dgamma(x, shape = 10.0, rate = 1), add = TRUE, col = "darkgreen", lwd = 2)
legend("topright", legend = c("Empirical", "Theoretical"),
       fill = c("lightcoral", NA), border = c("white", NA),
       col = c(NA, "darkgreen"), lwd = c(NA, 2), bty = "n")

# ---------------------------------------------------------
# Plot 4: Gamma-Ratio Beta Generator (a = 2.5, b = 5.0)
# ---------------------------------------------------------
hist(samples_Beta, probability = TRUE, breaks = 50, col = "plum",
     main = "Gamma Ratio: Beta(2.5, 5.0)", xlab = "x", ylab = "Density", border = "white")
curve(dbeta(x, shape1 = 2.5, shape2 = 5.0), add = TRUE, col = "purple", lwd = 2)
legend("topright", legend = c("Empirical", "Theoretical"),
       fill = c("plum", NA), border = c("white", NA),
       col = c(NA, "purple"), lwd = c(NA, 2), bty = "n")

# Reset plotting window
par(mfrow=c(1, 1))
```

```{r}
# The K-S test evaluates if the empirical sample distribution significantly deviates from the theoretical CDF.
# A p-value > 0.05 indicates we fail to reject the null hypothesis.

cat("--- K-S Test Results ---\n")

# Test Algorithm GS (a = 0.5)
ks_GS <- ks.test(samples_GS, "pgamma", shape = 0.5, rate = 1)
cat("Algorithm GS (a=0.5) p-value:", ks_GS$p.value, "\n")

# Test Algorithm GC (a = 2.0)
ks_GC <- ks.test(samples_GC, "pgamma", shape = 2.0, rate = 1)
cat("Algorithm GC (a=2.0) p-value:", ks_GC$p.value, "\n")

# Test Algorithm GO (a = 10.0)
ks_GO <- ks.test(samples_GO, "pgamma", shape = 10.0, rate = 1)
cat("Algorithm GO (a=10.0) p-value:", ks_GO$p.value, "\n")

# Test Gamma-Ratio Beta Generator (a = 2.5, b = 5.0)
ks_Beta <- ks.test(samples_Beta, "pbeta", shape1 = 2.5, shape2 = 5.0)
cat("Gamma-Ratio Beta Generator (a=2.5, b=5.0) p-value:", ks_Beta$p.value, "\n")
```